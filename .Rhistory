param["barmu"],
sqrt(param["sigma2mu"])
)
UB <- rnorm(N,
0,
sqrt(param["sigma2U"])
)
yB <- mu + UB
YB <- exp(yB)
par(mfrow=c(1,4))
plot(mu,main= 'mu')
plot(UB,main='UB')
plot(yB,main='yB')
plot(YB,main='YB')
Ds <- ifelse(YB<=param["barY"],1,0)
# building histogram of yB with cutoff point at ybar
# Number of steps
Nsteps.1 <- 15
#step width
step.1 <- (log(param["barY"])-min(yB[Ds==1]))/Nsteps.1
Nsteps.0 <- (-log(param["barY"])+max(yB[Ds==0]))/step.1
breaks <- cumsum(c(min(yB[Ds==1]),c(rep(step.1,Nsteps.1+Nsteps.0+1))))
hist(yB,breaks=breaks,main="")
abline(v=log(param["barY"]),col="red")
table.D.sharp <- as.matrix(table(Ds))
knitr::kable(table.D.sharp,caption='Treatment allocation with sharp cutoff rule',booktabs=TRUE)
param <- c(8,.5,.28,1500)
names(param) <- c("barmu","sigma2mu","sigma2U","barY")
# 1. 'barmu': Mean pre-intervention performance of all developers (8).
# 2. 'sigma2mu': Variance in mean pre-intervention performance across developers (0.5).
#This value determines how widely dispersed the mean pre-treatment performance is among different developers.
# 3. 'sigma2U': Variance in deviation from the mean pre-intervention performance of each individual developer (0.28).
#This value controls how much each developer's performance differs from the average performance.
# 4. 'barY': Threshold value for sharp cutoff rule (1500), which determines whether a developer receives the treatment based on their pre-intervention performance.
param
# for reproducibility, I choose a seed that will give me the same random sample each time I run the program
set.seed(1234)
N <-1000
mu <- rnorm(N,
param["barmu"],
sqrt(param["sigma2mu"])
)
UB <- rnorm(N,
0,
sqrt(param["sigma2U"])
)
yB <- mu + UB
YB <- exp(yB)
par(mfrow=c(1,4))
plot(mu,main= 'mu')
plot(UB,main='UB')
plot(yB,main='yB')
plot(YB,main='YB')
dev.off()
Ds <- ifelse(YB<=param["barY"],1,0)
# building histogram of yB with cutoff point at ybar
# Number of steps
Nsteps.1 <- 15
#step width
step.1 <- (log(param["barY"])-min(yB[Ds==1]))/Nsteps.1
Nsteps.0 <- (-log(param["barY"])+max(yB[Ds==0]))/step.1
breaks <- cumsum(c(min(yB[Ds==1]),c(rep(step.1,Nsteps.1+Nsteps.0+1))))
hist(yB,breaks=breaks,main="")
abline(v=log(param["barY"]),col="red")
table.D.sharp <- as.matrix(table(Ds))
knitr::kable(table.D.sharp,caption='Treatment allocation with sharp cutoff rule',booktabs=TRUE)
param <- c(8,.5,.28,1500)
names(param) <- c("barmu","sigma2mu","sigma2U","barY")
# 1. 'barmu': Mean pre-intervention performance of all developers (8).
# 2. 'sigma2mu': Variance in mean pre-intervention performance across developers (0.5).
#This value determines how widely dispersed the mean pre-treatment performance is among different developers.
# 3. 'sigma2U': Variance in deviation from the mean pre-intervention performance of each individual developer (0.28).
#This value controls how much each developer's performance differs from the average performance.
# 4. 'barY': Threshold value for sharp cutoff rule (1500), which determines whether a developer receives the treatment based on their pre-intervention performance.
param
# for reproducibility, I choose a seed that will give me the same random sample each time I run the program
set.seed(1234)
N <-1000
mu <- rnorm(N,
param["barmu"],
sqrt(param["sigma2mu"])
)
UB <- rnorm(N,
0,
sqrt(param["sigma2U"])
)
yB <- mu + UB
YB <- exp(yB)
par(mfrow=c(1,4))
plot(mu,main= 'mu')
plot(UB,main='UB')
plot(yB,main='yB')
plot(YB,main='YB')
Ds <- ifelse(YB<=param["barY"],1,0)
# building histogram of yB with cutoff point at ybar
# Number of steps
Nsteps.1 <- 15
#step width
step.1 <- (log(param["barY"])-min(yB[Ds==1]))/Nsteps.1
Nsteps.0 <- (-log(param["barY"])+max(yB[Ds==0]))/step.1
breaks <- cumsum(c(min(yB[Ds==1]),c(rep(step.1,Nsteps.1+Nsteps.0+1))))
dev.off()
hist(yB,breaks=breaks,main="")
abline(v=log(param["barY"]),col="red")
table.D.sharp <- as.matrix(table(Ds))
knitr::kable(table.D.sharp,caption='Treatment allocation with sharp cutoff rule',booktabs=TRUE)
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
names(param)[(l+1):length(param)] <- c("rho","theta","sigma2epsilon","sigma2eta","delta","baralpha")
param
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
names(param)[(l+1):length(param)] <- c("rho","theta","sigma2epsilon","sigma2eta","delta","baralpha")
param
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
names(param)[(l+1):length(param)] <- c("rho","theta","sigma2epsilon","sigma2eta","delta","baralpha")
param
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
param <- c(8,.5,.28,1500)
names(param) <- c("barmu","sigma2mu","sigma2U","barY")
# 1. 'barmu': Mean pre-intervention performance of all developers (8).
# 2. 'sigma2mu': Variance in mean pre-intervention performance across developers (0.5).
#This value determines how widely dispersed the mean pre-treatment performance is among different developers.
# 3. 'sigma2U': Variance in deviation from the mean pre-intervention performance of each individual developer (0.28).
#This value controls how much each developer's performance differs from the average performance.
# 4. 'barY': Threshold value for sharp cutoff rule (1500), which determines whether a developer receives the treatment based on their pre-intervention performance.
param
# for reproducibility, I choose a seed that will give me the same random sample each time I run the program
set.seed(1234)
N <-1000
mu <- rnorm(N,
param["barmu"],
sqrt(param["sigma2mu"])
)
UB <- rnorm(N,
0,
sqrt(param["sigma2U"])
)
yB <- mu + UB
YB <- exp(yB)
par(mfrow=c(1,4))
plot(mu,main= 'mu')
plot(UB,main='UB')
plot(yB,main='yB')
plot(YB,main='YB')
Ds <- ifelse(YB<=param["barY"],1,0)
# building histogram of yB with cutoff point at ybar
# Number of steps
Nsteps.1 <- 15
#step width
step.1 <- (log(param["barY"])-min(yB[Ds==1]))/Nsteps.1
Nsteps.0 <- (-log(param["barY"])+max(yB[Ds==0]))/step.1
breaks <- cumsum(c(min(yB[Ds==1]),c(rep(step.1,Nsteps.1+Nsteps.0+1))))
dev.off()
hist(yB,breaks=breaks,main="")
abline(v=log(param["barY"]),col="red")
table.D.sharp <- as.matrix(table(Ds))
knitr::kable(table.D.sharp,caption='Treatment allocation with sharp cutoff rule',booktabs=TRUE)
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
names(param)[(l+1):length(param)] <- c("rho","theta","sigma2epsilon","sigma2eta","delta","baralpha")
param
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
names(param)[(l+1):length(param)] <- c("rho","theta","sigma2epsilon","sigma2eta","delta","baralpha")
param
epsilon <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
eta<- rnorm(N,0,sqrt(param["sigma2eta"]))
U0 <- param["rho"]*UB + epsilon
y0 <- mu +  U0 + param["delta"]
alpha <- param["baralpha"]+  param["theta"]*mu + eta
y1 <- y0+alpha
Y0 <- exp(y0)
Y1 <- exp(y1)
plot(y0,y1)
param <- c(8,.5,.28,1500)
names(param) <- c("barmu","sigma2mu","sigma2U","barY")
# 1. 'barmu': Mean pre-intervention performance of all developers (8).
# 2. 'sigma2mu': Variance in mean pre-intervention performance across developers (0.5).
#This value determines how widely dispersed the mean pre-treatment performance is among different developers.
# 3. 'sigma2U': Variance in deviation from the mean pre-intervention performance of each individual developer (0.28).
#This value controls how much each developer's performance differs from the average performance.
# 4. 'barY': Threshold value for sharp cutoff rule (1500), which determines whether a developer receives the treatment based on their pre-intervention performance.
param
# for reproducibility, I choose a seed that will give me the same random sample each time I run the program
set.seed(1234)
N <-1000
mu <- rnorm(N,
param["barmu"],
sqrt(param["sigma2mu"])
)
UB <- rnorm(N,
0,
sqrt(param["sigma2U"])
)
yB <- mu + UB
YB <- exp(yB)
par(mfrow=c(1,4))
plot(mu,main= 'mu')
plot(UB,main='UB')
plot(yB,main='yB')
plot(YB,main='YB')
Ds <- ifelse(YB<=param["barY"],1,0)
# building histogram of yB with cutoff point at ybar
# Number of steps
Nsteps.1 <- 15
#step width
step.1 <- (log(param["barY"])-min(yB[Ds==1]))/Nsteps.1
Nsteps.0 <- (-log(param["barY"])+max(yB[Ds==0]))/step.1
breaks <- cumsum(c(min(yB[Ds==1]),c(rep(step.1,Nsteps.1+Nsteps.0+1))))
dev.off()
hist(yB,breaks=breaks,main="")
abline(v=log(param["barY"]),col="red")
table.D.sharp <- as.matrix(table(Ds))
knitr::kable(table.D.sharp,caption='Treatment allocation with sharp cutoff rule',booktabs=TRUE)
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
names(param)[(l+1):length(param)] <- c("rho","theta","sigma2epsilon","sigma2eta","delta","baralpha")
param
epsilon <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
eta<- rnorm(N,0,sqrt(param["sigma2eta"]))
U0 <- param["rho"]*UB + epsilon
y0 <- mu +  U0 + param["delta"]
alpha <- param["baralpha"]+  param["theta"]*mu + eta
y1 <- y0+alpha
Y0 <- exp(y0)
Y1 <- exp(y1)
plot(y0,y1)
param <- c(8,.5,.28,1500)
names(param) <- c("barmu","sigma2mu","sigma2U","barY")
# 1. 'barmu': Mean pre-intervention performance of all developers (8).
# 2. 'sigma2mu': Variance in mean pre-intervention performance across developers (0.5).
#This value determines how widely dispersed the mean pre-treatment performance is among different developers.
# 3. 'sigma2U': Variance in deviation from the mean pre-intervention performance of each individual developer (0.28).
#This value controls how much each developer's performance differs from the average performance.
# 4. 'barY': Threshold value for sharp cutoff rule (1500), which determines whether a developer receives the treatment based on their pre-intervention performance.
param
# for reproducibility, I choose a seed that will give me the same random sample each time I run the program
set.seed(1234)
N <-1000
mu <- rnorm(N,
param["barmu"],
sqrt(param["sigma2mu"])
)
UB <- rnorm(N,
0,
sqrt(param["sigma2U"])
)
yB <- mu + UB
YB <- exp(yB)
par(mfrow=c(1,4))
plot(mu,main= 'mu')
plot(UB,main='UB')
plot(yB,main='yB')
plot(YB,main='YB')
Ds <- ifelse(YB<=param["barY"],1,0)
# building histogram of yB with cutoff point at ybar
# Number of steps
Nsteps.1 <- 15
#step width
step.1 <- (log(param["barY"])-min(yB[Ds==1]))/Nsteps.1
Nsteps.0 <- (-log(param["barY"])+max(yB[Ds==0]))/step.1
breaks <- cumsum(c(min(yB[Ds==1]),c(rep(step.1,Nsteps.1+Nsteps.0+1))))
dev.off()
hist(yB,breaks=breaks,main="")
abline(v=log(param["barY"]),col="red")
table.D.sharp <- as.matrix(table(Ds))
knitr::kable(table.D.sharp,caption='Treatment allocation with sharp cutoff rule',booktabs=TRUE)
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
names(param)[(l+1):length(param)] <- c("rho","theta","sigma2epsilon","sigma2eta","delta","baralpha")
param
epsilon <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
eta<- rnorm(N,0,sqrt(param["sigma2eta"]))
U0 <- param["rho"]*UB + epsilon
y0 <- mu +  U0 + param["delta"]
alpha <- param["baralpha"]+  param["theta"]*mu + eta
y1 <- y0+alpha
Y0 <- exp(y0)
Y1 <- exp(y1)
plot(y0,y1)
plot(yB[Ds==0],y0[Ds==0],pch=1,xlim=c(5,11),ylim=c(5,11),xlab="yB",ylab="Outcomes")
points(yB[Ds==1],y1[Ds==1],pch=3)
points(yB[Ds==0],y1[Ds==0],pch=3,col='red')
points(yB[Ds==1],y0[Ds==1],pch=1,col='red')
test <- 5.8
i.test <- which(abs(yB-test)==min(abs(yB-test)))
points(yB[abs(yB-test)==min(abs(yB-test))],y1[abs(yB-test)==min(abs(yB-test))],col='green',pch=3)
points(yB[abs(yB-test)==min(abs(yB-test))],y0[abs(yB-test)==min(abs(yB-test))],col='green')
abline(v=log(param["barY"]),col="red")
legend(5,11,c('y0|D=0','y1|D=1','y0|D=1','y1|D=0',paste('y0',i.test,sep=''),paste('y1',i.test,sep='')),pch=c(1,3,1,3,1,3),col=c('black','black','red','red','green','green'),ncol=3)
plot(yB[Ds==0],y0[Ds==0],pch=1,xlim=c(5,11),ylim=c(5,11),xlab="yB",ylab="Outcomes")
points(yB[Ds==1],y1[Ds==1],pch=3)
legend(5,11,c('y|D=0','y|D=1'),pch=c(1,3))
abline(v=log(param["barY"]),col="red")
plot(yB[Ds==0],y0[Ds==0],pch=1,xlim=c(5,11),ylim=c(5,11),xlab="yB",ylab="Outcomes")
points(yB[Ds==1],y1[Ds==1],pch=3)
points(yB[Ds==0],y1[Ds==0],pch=3,col='red')
points(yB[Ds==1],y0[Ds==1],pch=1,col='red')
test <- 5.8
i.test <- which(abs(yB-test)==min(abs(yB-test)))
points(yB[abs(yB-test)==min(abs(yB-test))],y1[abs(yB-test)==min(abs(yB-test))],col='green',pch=3)
points(yB[abs(yB-test)==min(abs(yB-test))],y0[abs(yB-test)==min(abs(yB-test))],col='green')
abline(v=log(param["barY"]),col="red")
legend(5,11,c('y0|D=0','y1|D=1','y0|D=1','y1|D=0',paste('y0',i.test,sep=''),paste('y1',i.test,sep='')),pch=c(1,3,1,3,1,3),col=c('black','black','red','red','green','green'),ncol=3)
param <- c(8,.5,.28,1500)
names(param) <- c("barmu","sigma2mu","sigma2U","barY")
# 1. 'barmu': Mean pre-intervention performance of all developers (8).
# 2. 'sigma2mu': Variance in mean pre-intervention performance across developers (0.5).
#This value determines how widely dispersed the mean pre-treatment performance is among different developers.
# 3. 'sigma2U': Variance in deviation from the mean pre-intervention performance of each individual developer (0.28).
#This value controls how much each developer's performance differs from the average performance.
# 4. 'barY': Threshold value for sharp cutoff rule (1500), which determines whether a developer receives the treatment based on their pre-intervention performance.
param
# for reproducibility, I choose a seed that will give me the same random sample each time I run the program
set.seed(1234)
N <-1000
mu <- rnorm(N,
param["barmu"],
sqrt(param["sigma2mu"])
)
UB <- rnorm(N,
0,
sqrt(param["sigma2U"])
)
yB <- mu + UB
YB <- exp(yB)
par(mfrow=c(1,4))
plot(mu,main= 'mu')
plot(UB,main='UB')
plot(yB,main='yB')
plot(YB,main='YB')
Ds <- ifelse(YB<=param["barY"],1,0)
# building histogram of yB with cutoff point at ybar
# Number of steps
Nsteps.1 <- 15
#step width
step.1 <- (log(param["barY"])-min(yB[Ds==1]))/Nsteps.1
Nsteps.0 <- (-log(param["barY"])+max(yB[Ds==0]))/step.1
breaks <- cumsum(c(min(yB[Ds==1]),c(rep(step.1,Nsteps.1+Nsteps.0+1))))
dev.off()
hist(yB,breaks=breaks,main="")
abline(v=log(param["barY"]),col="red")
table.D.sharp <- as.matrix(table(Ds))
knitr::kable(table.D.sharp,caption='Treatment allocation with sharp cutoff rule',booktabs=TRUE)
l <- length(param)
param <- c(param,0.9,0.01,0.05,0.05,0.05,0.1)
names(param)[(l+1):length(param)] <- c("rho","theta","sigma2epsilon","sigma2eta","delta","baralpha")
param
epsilon <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
eta<- rnorm(N,0,sqrt(param["sigma2eta"]))
U0 <- param["rho"]*UB + epsilon
y0 <- mu +  U0 + param["delta"]
alpha <- param["baralpha"]+  param["theta"]*mu + eta
y1 <- y0+alpha
Y0 <- exp(y0)
Y1 <- exp(y1)
plot(y0,y1)
par(mfrow=c(1,2))
plot(yB[Ds==0],y0[Ds==0],pch=1,xlim=c(5,11),ylim=c(5,11),xlab="yB",ylab="Outcomes")
points(yB[Ds==1],y1[Ds==1],pch=3)
points(yB[Ds==0],y1[Ds==0],pch=3,col='red')
points(yB[Ds==1],y0[Ds==1],pch=1,col='red')
test <- 5.8
i.test <- which(abs(yB-test)==min(abs(yB-test)))
points(yB[abs(yB-test)==min(abs(yB-test))],y1[abs(yB-test)==min(abs(yB-test))],col='green',pch=3)
points(yB[abs(yB-test)==min(abs(yB-test))],y0[abs(yB-test)==min(abs(yB-test))],col='green')
abline(v=log(param["barY"]),col="red")
legend(5,11,c('y0|D=0','y1|D=1','y0|D=1','y1|D=0',paste('y0',i.test,sep=''),paste('y1',i.test,sep='')),pch=c(1,3,1,3,1,3),col=c('black','black','red','red','green','green'),ncol=3)
plot(yB[Ds==0],y0[Ds==0],pch=1,xlim=c(5,11),ylim=c(5,11),xlab="yB",ylab="Outcomes")
points(yB[Ds==1],y1[Ds==1],pch=3)
legend(5,11,c('y|D=0','y|D=1'),pch=c(1,3))
abline(v=log(param["barY"]),col="red")
dev.off()
setwd("~/Desktop/speechToSpeech")
setwd("~/Desktop/speechToSpeech")
library(shiny)
library(shinybusy)
#Libraries
library(httr)
library(jsonlite)
library(dplyr)
library(readr)
library(tuneR)
library(stringr)
conversation_history <- c()
source('./shiny_functions/functions.R')
ui <- fluidPage(
titlePanel("Voice Recording App"),
selectInput("recordType", "Select Record Type", choices = c("greeting", "continuedMessage")),
actionButton("startRecording", "Start Recording"),
actionButton("stopRecording", "Stop Recording"),
numericInput("responseLength", "Desired Response Length", value = 128, min = 1, max = 512, step = 1),
actionButton("sendToAPI", "Send to API"),
textOutput("recordingStatus"),
textOutput("apiResponse"),
add_busy_spinner()
)
server <- function(input, output, session) {
recording <- FALSE
currentRecording <- NULL
observeEvent(input$startRecording, {
if (!recording) {
recording <<- TRUE
if (input$recordType == "greeting") {
currentRecording <<- "greetingR.wav"
} else if (input$recordType == "continuedMessage") {
currentRecording <<- "test.wav"
}
# Start recording
system(paste0("rec -r 16000 ", currentRecording, " &"))
output$recordingStatus <- renderText("Recording started")
}
})
observeEvent(input$stopRecording, {
if (recording) {
recording <<- FALSE
# Stop recording
system(paste0("pkill -f 'rec -r 16000 ", currentRecording, "'"))
output$recordingStatus <- renderText("Recording stopped")
}
})
observeEvent(input$sendToAPI, {
if (!is.null(currentRecording)) {
# Call the appropriate function based on recording type
if (currentRecording == "greetingR.wav") {
api_response <- greeting(init_prompt = read_file('./prompts/init_alt.txt'),
userFirstMessage= greetingVoice(), maxLengthInput = input$responseLength)
renderResponse <- read_file('./greeting.txt')
renderResponse <- as.character(renderResponse)
} else if (currentRecording == "test.wav") {
api_response <- process_recorded_message(desiredLength = input$responseLength,
voiceID = "p301")
renderResponse <- read_file('./currentResponse.txt')
renderResponse <- as.character(renderResponse)
}
output$apiResponse <- renderText(renderResponse)
}
})
}
shinyApp(ui = ui, server = server)
setwd("~/Desktop/speechToSpeechLLM")
runApp('shiny.R')
library(shiny)
library(shinybusy)
#Libraries
library(httr)
library(jsonlite)
library(dplyr)
library(readr)
library(tuneR)
library(stringr)
conversation_history <- c()
source('./shiny_functions/functions.R')
ui <- fluidPage(
titlePanel("Voice Recording App"),
selectInput("recordType", "Select Record Type", choices = c("greeting", "continuedMessage")),
actionButton("startRecording", "Start Recording"),
actionButton("stopRecording", "Stop Recording"),
numericInput("responseLength", "Desired Response Length", value = 128, min = 1, max = 512, step = 1),
actionButton("sendToAPI", "Send to API"),
textOutput("recordingStatus"),
textOutput("apiResponse"),
add_busy_spinner()
)
server <- function(input, output, session) {
recording <- FALSE
currentRecording <- NULL
observeEvent(input$startRecording, {
if (!recording) {
recording <<- TRUE
if (input$recordType == "greeting") {
currentRecording <<- "greetingR.wav"
} else if (input$recordType == "continuedMessage") {
currentRecording <<- "test.wav"
}
# Start recording
system(paste0("rec -r 16000 ", currentRecording, " &"))
output$recordingStatus <- renderText("Recording started")
}
})
observeEvent(input$stopRecording, {
if (recording) {
recording <<- FALSE
# Stop recording
system(paste0("pkill -f 'rec -r 16000 ", currentRecording, "'"))
output$recordingStatus <- renderText("Recording stopped")
}
})
observeEvent(input$sendToAPI, {
if (!is.null(currentRecording)) {
# Call the appropriate function based on recording type
if (currentRecording == "greetingR.wav") {
api_response <- greeting(init_prompt = read_file('./prompts/init_alt.txt'),
userFirstMessage= greetingVoice(), maxLengthInput = input$responseLength)
renderResponse <- read_file('./greeting.txt')
renderResponse <- as.character(renderResponse)
} else if (currentRecording == "test.wav") {
api_response <- process_recorded_message(desiredLength = input$responseLength,
voiceID = "p301")
renderResponse <- read_file('./currentResponse.txt')
renderResponse <- as.character(renderResponse)
}
output$apiResponse <- renderText(renderResponse)
}
})
}
shinyApp(ui = ui, server = server)
shinyApp(ui = ui, server = server)
conversation_history
